package command

import (
	"fmt"
	"strings"

	"github.com/fextpkg/cli/fext/config"
	"github.com/fextpkg/cli/fext/ferror"
	"github.com/fextpkg/cli/fext/io"
	"github.com/fextpkg/cli/fext/pkg"
	"github.com/fextpkg/cli/fext/ui"
)

type Freeze struct {
	// Print style mode
	printMode string

	// Directory names with packages metadata for scanning and output
	metaDirectories []string
}

// getPrintFunc selects the functions responsible for the specified printMode. If
// there is not such a function, an error will be returned.
func (cmd *Freeze) getPrintFunc() (func(), error) {
	if cmd.printMode == "human" {
		return cmd.printStyleHuman, nil
	} else if cmd.printMode == "pip" {
		return cmd.printStylePIP, nil
	} else {
		return nil, &ferror.UnexpectedMode{Mode: cmd.printMode}
	}
}

// printStyleHuman outputs a list of packages in a human-readable style,
// including general info about the number of packages and their weight.
//
// Packages that failed to load will be displayed at the end as a warning line.
func (cmd *Freeze) printStyleHuman() {
	var brokenPackages []string
	var count int
	var size int64

	for _, metaDir := range cmd.metaDirectories {
		p, err := pkg.LoadFromMetaDir(metaDir)
		if err == nil {
			s, err := p.GetSize()
			if err != nil {
				brokenPackages = append(brokenPackages, metaDir)
				continue
			}

			size += s
			count++
			fmt.Printf("%s (%s)\n", p.Name, p.Version)
		} else {
			brokenPackages = append(brokenPackages, metaDir)
		}
	}

	fmt.Printf("\nTotal: %d (%.2f MB)\n", count, float32(size/1024)/1024)
	if len(brokenPackages) > 0 {
		ui.PrintfWarning(
			"During the package analysis, some errors has occurred with packages: %s\n",
			strings.Join(brokenPackages, ", "),
		)
	}
}

// printStylePIP outputs a list of packages in PIP style, but with comments.
// Packages that failed to load will be commented out.
func (cmd *Freeze) printStylePIP() {
	fmt.Printf(
		"# This file generated by Fext (%s)\n# Broken packages are commented out\n\n",
		config.Version,
	)

	for _, metaDir := range cmd.metaDirectories {
		p, err := pkg.LoadFromMetaDir(metaDir)
		if err == nil {
			fmt.Printf("%s==%s\n", p.Name, p.Version)
		} else {
			fmt.Printf("# %s\n", metaDir)
		}
	}
}

// DetectFlags analyzes the passed flags and fills in the variables associated
// with them.
//
// Returns ferror.HelpFlag if you need to print the docstring about this command.
// Returns ferror.UnknownFlag if passed the unknown flag.
// Returns ferror.MissingOptionValue if the correct but empty option is passed.
func (cmd *Freeze) DetectFlags() error {
	for _, f := range config.Flags {
		if f == "h" || f == "help" { // Help flag
			return ferror.HelpFlag
		} else if strings.HasPrefix(f, "m=") || strings.HasPrefix(f, "mode=") {
			// Print style mode. To preserve performance and foundation, we do not add a
			// structure for flags with a value. Instead, parse these flag in only "freeze"
			// command. But it may have to be redone in the future. Who knowsâ€¦
			cmd.printMode = strings.SplitN(f, "=", 2)[1]
			if cmd.printMode == "" { // Empty value
				return &ferror.MissingOptionValue{Opt: f[:len(f)-1]}
			}
		} else if f == "m" || f == "mode" { // Passed "mode" option without value
			return &ferror.MissingOptionValue{Opt: f}
		} else { // Unexpected flag
			return &ferror.UnknownFlag{Flag: f}
		}
	}

	return nil
}

// Execute prints a list of packages in the selected printMode.
func (cmd *Freeze) Execute() {
	fn, err := cmd.getPrintFunc()
	if err != nil {
		ui.Fatal("Unable to select print mode:", err.Error())
	}

	cmd.metaDirectories, err = io.GetMetaDirectories()
	if err != nil {
		ui.Fatal("Unable to scan meta directories:", err.Error())
	}

	fn()
}

// InitFreeze initializes the "freeze" command structure with default parameters.
func InitFreeze() *Freeze {
	return &Freeze{
		printMode: "human",
	}
}
